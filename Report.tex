\documentclass[a4paper,12pt,titlepage,finall]{article}

\usepackage[russian]{babel}
\usepackage{geometry}
\usepackage{multirow}
\usepackage{indentfirst}

\geometry{a4paper,left=30mm,top=30mm,bottom=30mm,right=30mm}

\begin{document}

% Титульный лист
\begin{titlepage}
    \begin{center}
    {\small \sc Московский государственный университет \\имени М.~В.~Ломоносова\\ Факультет вычислительной математики и кибернетики\\}
    \vfill
    {\large \sc Отчёт по заданию №1}\\~\\
    {\large \bf <<Методы сортировки>>}\\~\\
    {\large \bf Вариант 3 / 1 / 1 / 5}
    \end{center}

    \begin{flushright}
    \vfill
    {Выполнил:\\студент 105 группы\\Космынин~И.~Н.\\~\\
    Преподаватели:\\Гуляев~А.~В.\\Русол~А.~В.}
    \end{flushright}

    \begin{center}
    \vfill
    {\small Москва\\2024}
    \end{center}
\end{titlepage}

\tableofcontents
\newpage

\section{Постановка задачи}

Реализовать пузырьковую и пирамидальную сортировки по неубыванию, экспериментально сравнить их эффективность. Измерение эффективности каждого метода сортировки ведётся по числу перемещений и числу сравнений. Для сортировки используются динамические массивы вещественных чисел двойной точности (double) различной длины, элементы которых расположены в порядке неубывания, невозрастания и в случайном порядке.

\newpage

\section{Результаты экспериментов}

Согласно теоретическим предположениям\cite{cs}, время работы сортировки пузырьком равно $\mathcal{O}(n^2)$, а у пирамидальной сортировки --- $\mathcal{O}(n\log_2{n})$. Таким образом, в случае пузырьковой сортировки число перемещений и сравнений элементов на больших наборах данных должны сильно превышать соответствующие параметры пирамидальной сортировки. Экспериментальные данные (при сиде 42), подтверждающие теоретические предположения, указаны в следующих таблицах:
% BubbleSort
\begin{table}[h]
\centering
\begin{tabular}{|c|c|c|c|c|c|c|c|}
\hline
\multirow{2}{*}{\textbf{n}} & \multirow{2}{*}{\textbf{Параметр}} & \multicolumn{4}{|c|}{\textbf{Номер сгенерированного массива}} & \textbf{Среднее} \\
\cline{3-6}
& & \parbox{1.5cm}{\centering 1} & \parbox{1.5cm}{\centering 2} & \parbox{1.5cm}{\centering 3} & \parbox{1.5cm}{\centering 4} & \textbf{Значение} \\
\hline
\multirow{2}{*}{10} & Сравнения & 45 & 45 & 45 & 45 & 45 \\
\cline{2-7}
& Перемещения & 0 & 45 & 21 & 31 & 24,25 \\
\hline
\multirow{2}{*}{100} & Сравнения & 4950 & 4950 & 4950 & 4950 & 4950 \\
\cline{2-7}
& Перемещения & 0 & 4950 & 2405 & 2461 & 2454 \\
\hline
\multirow{2}{*}{1000} & Сравнения & 499500 & 499500 & 499500 & 499500 & 499500 \\
\cline{2-7}
& Перемещения & 0 & 499500 & 250558 & 251849 & 250476,75 \\
\hline
\multirow{2}{*}{10000} & Сравнения & 49995000 & 49995000 & 49995000 & 49995000 & 49995000 \\
\cline{2-7}
& Перемещения & 0 & 49995000 & 24977250 & 25031015 & 81325816,25 \\
\hline
\end{tabular}
\caption{Результаты работы пузырьковой сортировки}
\end{table}
% HeapSort
\begin{table}[h]
\centering
\begin{tabular}{|c|c|c|c|c|c|c|c|}
\hline
\multirow{2}{*}{\textbf{n}} & \multirow{2}{*}{\textbf{Параметр}} & \multicolumn{4}{|c|}{\textbf{Номер сгенерированного массива}} & \textbf{Среднее} \\
\cline{3-6}
& & \parbox{1.5cm}{\centering 1} & \parbox{1.5cm}{\centering 2} & \parbox{1.5cm}{\centering 3} & \parbox{1.5cm}{\centering 4} & \textbf{Значение} \\
\hline
\multirow{2}{*}{10} & Сравнения & 70 & 52 & 64 & 64 & 62,5 \\
\cline{2-7}
& Перемещения & 30 & 21 & 27 & 27 & 26,25 \\
\hline
\multirow{2}{*}{100} & Сравнения & 1380 & 1132 & 1278 & 1290 & 1270 \\
\cline{2-7}
& Перемещения & 640 & 516 & 589 & 595 & 585 \\
\hline
\multirow{2}{*}{1000} & Сравнения & 20416 & 17632 & 19216 & 19226 & 19122,5 \\
\cline{2-7}
& Перемещения & 9708 & 8316 & 9108 & 9113 & 9061,25 \\
\hline
\multirow{2}{*}{10000} & Сравнения & 273912 & 243392 & 258294 & 258118 & 258429 \\
\cline{2-7}
& Перемещения & 131956 & 116696 & 124147 & 124059 & 124214,5 \\
\hline
\end{tabular}
\caption{Результаты работы пирамидальной сортировки}
\end{table}

Таблицы показывают, что при малых значениях N пирамидальная сортировка не даёт никаких преимуществ, но при росте N число сравнений и перемещений растёт не так стремительно, то есть асимптотически она быстрее.

\newpage

\section{Структура программы и спецификация функций}

При работе программы используются две глобальные переменные comps и swaps типа long long, необходимые для подсчёта количества сравнений и перемещений для каждой сортировки.\\

Функция main сначала анализирует аргументы, с которыми была запущенна программа. При необходимости указывается верный вариант использования программы и выводится справка. Если пользователь запросил полную таблицу, вызывается функция print\_table, если пользователь запросил лишь замеры быстродействия сортировок на определенном наборе данных, функция main вызывает generate\_arr для генерации необходимых массивов, к ним применяются сортировки, а результаты печатаются в консоль.\\

Полный список используемых функций:
\begin{itemize}
\item \begin{verbatim}void swap(double *a, double *b)\end{verbatim} меняет значения переменных a и b между собой;
\item \begin{verbatim}void bubble_sort(int n, double *arr)\end{verbatim}применяет алгоритм сортировки пузырьком к массиву arr длины n и считает кол-во сравнений и перемещений;
\item \begin{verbatim}void heapify(int n, int i, double *arr)\end{verbatim} выполняет одну процедуру просеивания кучи arr длины n начиная с эл-та под индексом i, при этом считает число сравнений и перемещений;
\item \begin{verbatim}void heap_sort(int n, double *arr)\end{verbatim} применяет алгоритм пирамидальной сортировки к массиву arr длины n и считает кол-во сравнений и перемещений;
\item \begin{verbatim}double* generate_arr(int n, int type)\end{verbatim} создаёт и возвращает массивы эл-ов double длины n, причём изначальный порядок эл-ов зависит от параметра type: \begin{enumerate} \item массив упорядочен по возрастанию, \item массив упорядочен по убыванию, \item элементы расположены в случайном порядке; \end{enumerate}
\item \begin{verbatim}void print_table()\end{verbatim} вычисляет и выводит в таблице число сравнений и перемещений при пузырьковой и пирамидальной сортировках на разных наборах данных;
\item \begin{verbatim}void print_usage(char *arg)\end{verbatim} выводит справку о вариантах использования программы, параметр arg отвечает за название исполняемого файла;
\item \begin{verbatim}void print_help(char *arg)\end{verbatim} выводит полную справку по программе, параметр arg отвечает за название исполняемого файла.
\end{itemize}

\newpage

\section{Отладка программы, тестирование функций}

Для проверки корректности реализации алгоритмов сортировки сравнивались несколько заранее подготовленных массивов до и после сортировки.\\

При тестировании функции генерации массивов особое внимание уделялось массивам со случайным порядком элементом. Необходимо было добиться генерации различных массивов при нескольких запусках программы.\\

Большое количество времени ушло на написание и отладку функции для вывода полной таблицы, т.к. размер ячеек и форматирование вывода подбирались опытным путём.

\newpage

\section{Анализ допущенных ошибок}

Первоначально были допущены ошибки при обработке аргументов программы, из-за чего она могла запускаться при неверных параметрах. К примеру, можно было одновременно указать параметры -t и -bs, что приводило к неадекватной работе приложения.\\

Вторая проблема была связана с тем, что я забыл задать сид для функции генерации псевдослучайных чисел. Из-за этого при каждом запуске программы массивы, которые должны были состоять из случайных элементов, создавались одни и те же.

\newpage

\begin{raggedright}
\addcontentsline{toc}{section}{Список цитируемой литературы}
\begin{thebibliography}{99}
\bibitem{cs} Кормен Т., Лейзерсон Ч., Ривест Р, Штайн К. Алгоритмы: построение и анализ. Второе издание.~--- М.:<<Вильямс>>, 2005.
\end{thebibliography}
\end{raggedright}

\end{document}